import { v4 as uuidV4 } from 'uuid';
import { PoolClient } from 'pg';
import { pool } from '../../../shared/infra/db';
import { Ticket } from '../domain/Ticket';
import { TicketRepository } from '../domain/TicketRepository';
import { TicketTipoRepository } from '../domain/TicketTipoRepository';
import { UserRepository } from '../../users/domain/UserRepository';
import { CreditRepository } from '../../creditos/domain/CreditRepository';
import { PgTicketRepository } from '../infra/PgTicketRepository';
import { PgUserRepository } from '../../users/infra/PgUserRepository';
import { PgCreditRepository } from '../../creditos/infra/PgCreditRepository';
import { PgUserVehicleRepository } from '../../users/infra/PgUserVehicleRepository';
import { CreditMovement } from '../../creditos/domain/CreditMovement';

interface CriarTicketInput {
  userId: string;
  tipoHoras: number;
  timestampEntrada: Date;
  placaDoCarro?: string;
  usarCredito: boolean;
}

interface CriarTicketOutput {
  id: string;
  status: string;
  valorOriginal: number;
  valorAtual: number;
  timestampEntrada: Date;
  timestampSaida: Date;
  placaDoCarro: string;
  creditoAplicado: number;
}

export class CriarTicket {
  constructor(
    private readonly tipoRepo: TicketTipoRepository
  ) { }

  async executar(input: CriarTicketInput): Promise<CriarTicketOutput> {
    const client: PoolClient = await pool.connect();

    try {
      await client.query('BEGIN');

      // Instantiate repos with the transactional client
      const ticketRepo = new PgTicketRepository(client);
      const userRepo = new PgUserRepository(client);
      const vehicleRepo = new PgUserVehicleRepository(client);
      const creditRepo = new PgCreditRepository(client);

      const tipo = await this.tipoRepo.buscarPorHoras(input.tipoHoras); // Read-only, no lock needed usually

      if (!tipo) {
        throw new Error(`Tipo de ticket com ${input.tipoHoras} horas não encontrado.`);
      }

      // Lock User if using credit
      let creditoAplicado = 0;
      let placaFinal = input.placaDoCarro;

      // 1. Get User (and lock if using credit or to get default plate)
      // Even if not using credit, we might want to get user for default plate.
      // If using credit, we MUST lock to ensure balance consistency.
      const user = input.usarCredito
        ? await userRepo.buscarPorIdComLock(input.userId)
        : await userRepo.buscarPorId(input.userId);

      if (!user) {
        throw new Error('Usuário não encontrado.');
      }

      if (!placaFinal) {
        // Buscar veículos do usuário
        const veiculos = await vehicleRepo.buscarVeiculosPorUsuario(user.id);
        if (veiculos.length === 0) {
          throw new Error('Placa do carro obrigatória e não cadastrada no usuário.');
        }
        // Usa a primeira placa encontrada como padrão se não foi informada
        placaFinal = veiculos[0].placa;
      }

      const timestampSaida = new Date(input.timestampEntrada);
      timestampSaida.setHours(timestampSaida.getHours() + input.tipoHoras);

      const valorOriginal = tipo.valorTotal;
      let valorAtual = valorOriginal;

      // 2. Apply Credit Logic
      if (input.usarCredito) {
        if (user.creditoSaldo > 0) {
          const saldoDisponivel = Number(user.creditoSaldo);
          creditoAplicado = Math.min(saldoDisponivel, valorOriginal);
          valorAtual = Math.max(0, valorOriginal - creditoAplicado);

          // Update user balance
          await userRepo.atualizarSaldo(user.id, saldoDisponivel - creditoAplicado);

          // Register Credit Movement
          // We need to create ticket first to Reference ID or generate ID beforehand.
          // Ticket ID is generated by UUID, so we can use it.
        }
      }

      // 3. Create Ticket
      const ticketId = uuidV4();
      const ticket = Ticket.create({
        id: ticketId,
        userId: user.id,
        tipoId: tipo.id,
        valorOriginal,
        timestampEntrada: input.timestampEntrada,
        timestampSaida,
        placaDoCarro: placaFinal,
        criadoEm: new Date()
      });

      // Override valorAtual if credit applied (Ticket.create sets valorAtual = valorOriginal)
      // Since Ticket entity encapsulates logic, we might need a method or recreate.
      // Ticket.reconstruir allows setting arbitrary values.
      // But cleaner is to let create happen and then update? Or pass correct value to create?
      // Ticket.create forces valorAtual = valorOriginal.
      // I should update Ticket entity to allow initial valorAtual or use ApplyDiscount alike method?
      // Or just cheat with rebuild.
      // Let's use rebuild logic or just instantiate directly via private constructor if I could, but factory is static.
      // The "proper" DDD way: apply a "CreditPayment" domain event/method?
      // For now, I'll allow recreating it with correct value or just update it via repository if the entity allows logic.
      // Actually Ticket.create logic is simple.
      // Let's just Apply Discount Logic method? "aplicarCredito"?
      // I'll manually construct the object to save to DB with correct value.

      const ticketParaSalvar = Ticket.reconstruir({
        id: ticket.id,
        userId: ticket.userId,
        tipoId: ticket.tipoId,
        status: ticket.status,
        valorOriginal: ticket.valorOriginal,
        valorAtual: valorAtual, // Applied credit
        timestampEntrada: ticket.timestampEntrada,
        timestampSaida: ticket.timestampSaida,
        placaDoCarro: ticket.placaDoCarro,
        criadoEm: ticket.criadoEm
      });

      await ticketRepo.criar(ticketParaSalvar);

      // 4. Register Movement if credit used
      if (creditoAplicado > 0) {
        await creditRepo.criar(CreditMovement.criar({
          id: uuidV4(),
          userId: user.id,
          tipo: 'USO_CREDITO_NO_TICKET',
          valor: creditoAplicado,
          direcao: 'SAIDA',
          referenciaTicketId: ticketId,
          criadoEm: new Date()
        }));
      }

      await client.query('COMMIT');

      return {
        id: ticketId,
        status: ticketParaSalvar.status,
        valorOriginal: ticketParaSalvar.valorOriginal,
        valorAtual: ticketParaSalvar.valorAtual,
        timestampEntrada: ticketParaSalvar.timestampEntrada,
        timestampSaida: ticketParaSalvar.timestampSaida,
        placaDoCarro: ticketParaSalvar.placaDoCarro,
        creditoAplicado
      };

    } catch (e) {
      await client.query('ROLLBACK');
      throw e;
    } finally {
      client.release();
    }
  }
}
